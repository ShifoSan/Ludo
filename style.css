:root {
    --color-blue: #2196F3;
    --color-green: #4CAF50;
    --color-red: #F44336;
    --color-yellow: #FFD600; /* Slightly darker for better contrast */
    --color-white: #ffffff;
    --color-black: #333333;
    --board-bg: #fff;
    --border-color: #000;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    user-select: none; /* Prevent selection during gameplay */
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #f0f2f5;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden; /* Prevent scrolling */
}

#game-container {
    position: relative;
    width: 95vmin;
    height: 95vmin;
    background: var(--color-white);
    box-shadow: 0 10px 25px rgba(0,0,0,0.2);
    border-radius: 8px;
    padding: 1vmin;
}

.ludo-board {
    width: 100%;
    height: 100%;
    display: grid;
    grid-template-columns: repeat(15, 1fr);
    grid-template-rows: repeat(15, 1fr);
    border: 2px solid var(--border-color);
    background-color: var(--board-bg);
}

/* Base Styles - Will occupy 6x6 corners */
.base {
    border: 1px solid var(--border-color);
    padding: 15%; /* Inner padding for the white box */
}

.base.blue-base {
    grid-column: 1 / 7;
    grid-row: 1 / 7;
    background-color: var(--color-blue);
}

.base.green-base {
    grid-column: 10 / 16;
    grid-row: 1 / 7;
    background-color: var(--color-green);
}

.base.red-base {
    grid-column: 10 / 16;
    grid-row: 10 / 16;
    background-color: var(--color-red);
}

.base.yellow-base {
    grid-column: 1 / 7;
    grid-row: 10 / 16;
    background-color: var(--color-yellow);
}

.base-inner {
    width: 100%;
    height: 100%;
    background-color: white;
    border-radius: 10%;
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    place-items: center;
    padding: 10%;
}

/* Center Home */
.home-triangle {
    grid-column: 7 / 10;
    grid-row: 7 / 10;
    background: conic-gradient(
        var(--color-green) 45deg,
        var(--color-red) 135deg,
        var(--color-yellow) 225deg,
        var(--color-blue) 315deg
    );
    border: 1px solid black;
    position: relative;
}
/* We can add a white center triangle overlay if needed later */

/* Dice UI */
.dice-container {
    position: absolute;
    /* Initial position, will be moved by JS */
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 100;
}

.dice {
    width: 8vmin;
    height: 8vmin;
    background-color: white;
    border: 2px solid #333;
    border-radius: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 4vmin;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    transition: transform 0.2s;
}

.dice:active {
    transform: scale(0.9);
}

/* Dice Positions */
.dice-container {
    transition: top 0.5s ease, left 0.5s ease;
}

.dice-pos-0 { top: 42%; left: 42%; } /* Blue (TL) */
.dice-pos-1 { top: 58%; left: 58%; } /* Red (BR) - Wait, prompt says Blue->Red->Green->Yellow */
/* Let's double check quadrant mapping to Turn Index */
/* Turn 0: Blue (TL) */
/* Turn 1: Red (BR) ?? Prompt: "Turn order: Clockwise (Blue -> Red -> Green -> Yellow)" */
/* But spatially: Blue(TL), Green(TR), Red(BR), Yellow(BL). */
/* If Turn 1 is Red (BR), then dice goes to BR */
/* Turn 2: Green (TR). Dice goes to TR */
/* Turn 3: Yellow (BL). Dice goes to BL */

.dice-pos-blue { top: 42%; left: 42%; }
.dice-pos-red { top: 58%; left: 58%; }
.dice-pos-green { top: 42%; left: 58%; }
.dice-pos-yellow { top: 58%; left: 42%; }

#status-message {
    position: absolute;
    top: 5px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255,255,255,0.9);
    padding: 5px 15px;
    border-radius: 20px;
    font-weight: bold;
    pointer-events: none;
    z-index: 50;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

/* Board Cells */
.cell {
    border: 1px solid #333;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    background-color: white;
}

.cell-home-blue { background-color: var(--color-blue); }
.cell-home-green { background-color: var(--color-green); }
.cell-home-red { background-color: var(--color-red); }
.cell-home-yellow { background-color: var(--color-yellow); }

.cell.safe-zone {
    background-color: #f0f0f0; /* Light grey for safe zones? Or keep white */
}

/* Icons */
.icon {
    width: 60%;
    height: 60%;
    opacity: 0.5;
}

.cell-start-blue { background-color: var(--color-blue); }
.cell-start-green { background-color: var(--color-green); }
.cell-start-red { background-color: var(--color-red); }
.cell-start-yellow { background-color: var(--color-yellow); }

/* Start cells usually have the color of the player */
.cell-start-blue .icon, .cell-start-green .icon, .cell-start-red .icon, .cell-start-yellow .icon {
    fill: white;
    opacity: 0.8;
}

/* Tokens */
.token {
    width: 70%;
    height: 70%;
    border-radius: 50%;
    border: 2px solid rgba(0,0,0,0.2);
    box-shadow: 2px 2px 5px rgba(0,0,0,0.5), inset 2px 2px 5px rgba(255,255,255,0.5);
    z-index: 10;
    transition: all 0.3s ease-in-out;
    cursor: pointer;
    position: relative;
    /* Center in the grid cell */
    justify-self: center;
    align-self: center;
}

.token.token-blue { background-color: var(--color-blue); }
.token.token-green { background-color: var(--color-green); }
.token.token-red { background-color: var(--color-red); }
.token.token-yellow { background-color: var(--color-yellow); }

/* Stacked Tokens (Mini-grid) */
/* We will handle stacking via inline styles or specific container classes if needed,
   but since tokens are grid items, we might need a wrapper if multiple are in one cell.
   However, the plan says "Visual Stacking... mini-grid".
   If we reparent them into a cell-wrapper, we break the grid positioning logic
   unless we put them into the generated .cell divs.

   BETTER APPROACH: Put tokens INSIDE the .cell divs (or base divs).
   When moving, we appendChild the token to the new target cell.
   This automatically handles responsiveness and position.

   If multiple tokens are in one cell, the cell acts as a flex/grid container.
*/
.cell {
    /* Updated for stacking */
    display: flex;
    flex-wrap: wrap;
    align-content: center;
    justify-content: center;
    gap: 2px;
}

/* Adjust token size if multiple are in a cell?
   We can do this via JS or CSS has() selector (not fully supported everywhere yet).
   Or just keep them small enough.
   70% is fine for 1. For 4, 30% might be better.
*/

/* Dice Animation */
@keyframes shake {
    0% { transform: translate(0, 0) rotate(0deg); }
    25% { transform: translate(5px, 5px) rotate(5deg); }
    50% { transform: translate(0, 0) rotate(0deg); }
    75% { transform: translate(-5px, 5px) rotate(-5deg); }
    100% { transform: translate(0, 0) rotate(0deg); }
}

.dice-shake {
    animation: shake 0.5s infinite;
}

/* Active Player Indicator */
.active-player-blue { border: 4px solid var(--color-blue); }
.active-player-green { border: 4px solid var(--color-green); }
.active-player-red { border: 4px solid var(--color-red); }
.active-player-yellow { border: 4px solid var(--color-yellow); }

/* Highlight Valid Moves */
.token.valid-move {
    animation: pulse 1s infinite;
    box-shadow: 0 0 10px 4px rgba(255, 255, 255, 0.8);
    z-index: 20;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}
